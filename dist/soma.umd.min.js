/* soma - v4.0.0 - 18/01/2026 - https://github.com/soundstep/soma */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).soma={})}(this,function(t){"use strict";const e=/^function\s*[^\(]*\(\s*([^\)]*)\)/m,i=/(?!function)\s*constructor\s*[^\(|function]*\(\s*([^\)]*)\)\s*{/m,n=/,/,s=/^\s*(_?)(\S+?)\1\s*$/,r=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,o={};o.errors={MAPPING_BAD_PROP:"[Error Injector.MAPPING_BAD_PROP] The first parameter is invalid, a string is expected.",MAPPING_BAD_VALUE:"[Error Injector.MAPPING_BAD_VALUE] The second parameter is invalid, it can't null or undefined, with property: ",MAPPING_BAD_CLASS:"[Error Injector.MAPPING_BAD_CLASS] The second parameter is invalid, a function is expected, with property: ",MAPPING_BAD_SINGLETON:"[Error Injector.MAPPING_BAD_SINGLETON] The third parameter is invalid, a boolean is expected, with property: ",MAPPING_ALREADY_EXISTS:"[Error Injector.MAPPING_ALREADY_EXISTS] This mapping already exists, with property: ",CREATE_INSTANCE_INVALID_PARAM:"[Error Injector.CREATE_INSTANCE_INVALID_PARAM] Invalid parameter, a function is expected.",NO_MAPPING_FOUND:"[Error Injector.NO_MAPPING_FOUND] No mapping found",INJECT_INSTANCE_IN_ITSELF_PROPERTY:"[Error Injector.INJECT_INSTANCE_IN_ITSELF_PROPERTY] A matching property `%p` has been found in the target, you can't inject an instance in itself.",INJECT_INSTANCE_IN_ITSELF_CONSTRUCTOR:"[Error Injector.INJECT_INSTANCE_IN_ITSELF_CONSTRUCTOR] A matching constructor parameter has been found in the target, you can't inject an instance in itself.",DEPENDENCIES_MISSING_IN_STRICT_MODE:'[Error Injector.DEPENDENCIES_MISSING_IN_STRICT_MODE] An "inject" property (array) that describes the dependencies is missing in strict mode.',DEPENDENCIES_MISSING_IN_STRICT_MODE_CONSTRUCTOR_INJECTION:'[Error Injector.DEPENDENCIES_MISSING_IN_STRICT_MODE_CONSTRUCTOR_INJECTION] An "inject" property (array) that describes the dependencies of constructor is missing in strict mode.',DEPENDENCIES_INVALID_TARGET:"[Error Injector.DEPENDENCIES_INVALID_TARGET] Invalid target, a function or a class is expected (arrow function cannot be instantiated)."};class c{constructor(t,e,i,n){this.prop=t,this.value=e,this.cl=i,this.singleton=n||!1,this.singletonPostConstructed=!1}}const a=t=>{if("string"!=typeof t)throw new Error(o.errors.MAPPING_BAD_PROP)},p=(t,e)=>{if(function(t,e){let i=t.length;for(;i--;)if(t[i]===e)return!0;return!1}(o.getDependencies(e),t))throw new Error(o.errors.INJECT_INSTANCE_IN_ITSELF_CONSTRUCTOR)},h=(t,e)=>{const i=void 0!==t?' for the injection name: "'+t+'"':"",n=void 0!==e?' when instantiating: "'+e+'"':"";return o.errors.NO_MAPPING_FOUND+i+n+"."};class l{constructor(){this.mappings={},this.parent=null,this.strictMode=!1,this.strictModeConstructorInjection=!1,this.throwOnMissing=!0}createChild(){const t=new l;return t.parent=this,t.strictMode=this.strictMode,t.strictModeConstructorInjection=this.strictModeConstructorInjection,t.throwOnMissing=this.throwOnMissing,t}getMappingVo(t){return this.mappings?this.mappings[t]?this.mappings[t]:this.parent?this.parent.getMappingVo(t):null:null}mapValue(t,e){if(this.mappings[t])throw new Error(o.errors.MAPPING_ALREADY_EXISTS+t);return a(t),((t,e)=>{if(null==e)throw new Error(o.errors.MAPPING_BAD_VALUE+t)})(t,e),this.mappings[t]=new c(t,e,null,!1),this}mapClass(t,e,i){if(this.mappings[t])throw new Error(o.errors.MAPPING_ALREADY_EXISTS+t+"  in "+(e.name??"n/a"));return a(t),((t,e)=>{if("function"!=typeof e)throw new Error(o.errors.MAPPING_BAD_CLASS+t)})(t,e),i&&((t,e)=>{if("boolean"!=typeof e)throw new Error(o.errors.MAPPING_BAD_SINGLETON+t)})(t,i),this.mappings[t]=new c(t,null,e,i||!1),this}removeMapping(t){return this.mappings[t]=null,delete this.mappings[t],this}hasMapping(t){return!!this.mappings[t]}hasInheritedMapping(t){return!!this.getMappingVo(t)}getMapping(t){for(const e in this.mappings)if(this.mappings.hasOwnProperty(e)){const i=this.mappings[e];if(i.value===t||i.cl===t)return i.prop}}getValue(t,...e){let i=this.mappings[t];if(!i){if(!this.parent){if(this.throwOnMissing)throw new Error(h(t));return}if(i=this.parent.getMappingVo(t),!i){if(this.throwOnMissing)throw new Error(h(t));return}}return i.cl?i.singleton?(i.value||(i.value=this.instantiate(i.cl,...e),this.inject(i.value),"function"==typeof i.value.postConstruct&&i.value.postConstruct()),i.value):this.createInstance(i.cl,...e):i.value}getClass(t){const e=this.mappings[t];if(e){if(e.cl)return e.cl}else if(this.parent){const e=this.parent.getMappingVo(t);if(e&&e.cl)return e.cl}}instantiate(t,...e){if("function"!=typeof t)throw new Error(o.errors.CREATE_INSTANCE_INVALID_PARAM);const i=o.getDependencies(t),n=o.getExplicitInjectDependencies(t).length,s=t.hasOwnProperty("inject");if(this.strictMode&&!s)throw new Error(o.errors.DEPENDENCIES_MISSING_IN_STRICT_MODE+" : "+t.name+"("+i.join(", ")+")");if(this.strictModeConstructorInjection&&i.length>0&&!s)throw new Error(o.errors.DEPENDENCIES_MISSING_IN_STRICT_MODE_CONSTRUCTOR_INJECTION+" : "+t.name+"("+i.join(", ")+")");const r=[null],c=i.length-n,a=e.length>c||0===c;for(let o=0,c=i.length;o<c;o++)if(a)if(e.length>o)r.push(e[o]);else{const e=i[o],n=this.getMappingVo(e);if(n)r.push(this.getInjectedValue(n,e));else{if(this.throwOnMissing&&(!this.strictMode||!s))throw new Error(h(e,t.name));r.push(void 0)}}else if(o<n){const e=i[o],n=this.getMappingVo(e);if(n)r.push(this.getInjectedValue(n,e));else{if(this.throwOnMissing&&!s)throw new Error(h(e,t.name));r.push(void 0)}}else{const s=o-n;if(e.length>s)r.push(e[s]);else{const e=i[o],n=this.getMappingVo(e);if(n)r.push(this.getInjectedValue(n,e));else{if(this.throwOnMissing)throw new Error(h(e,t.name));r.push(void 0)}}}for(let t=i.length;t<e.length;t++)r.push(e[t]);return new(Function.prototype.bind.apply(t,r))}inject(t,e){this.parent&&this.parent.inject(t,!0),o.getExplicitInjectDependencies(t.constructor);for(const e in this.mappings)if(this.mappings.hasOwnProperty(e)){const i=this.mappings[e];i&&(t.hasOwnProperty(i.prop)||void 0!==t[i.prop]||t.constructor&&t.constructor.prototype&&t.constructor.prototype.hasOwnProperty(i.prop)||void 0!==t.constructor.inject&&t.constructor.inject.includes(i.prop))&&(t[e]=this.getInjectedValue(i,e))}return this}getInjectedValue(t,e){let i,n=t.value;return t.cl&&(t.singleton?(t.value||(p(e,t.cl),t.value=this.instantiate(t.cl),i=t.value),n=t.value):(p(e,t.cl),n=this.instantiate(t.cl),i=n)),i&&(((t,e)=>{if(e.hasOwnProperty(t))throw new Error(o.errors.INJECT_INSTANCE_IN_ITSELF_PROPERTY.replace("%p",t))})(e,i),this.inject(i),"function"==typeof i.postConstruct&&i.postConstruct()),n}createInstance(t,...e){const i=this.instantiate(t,...e);return this.inject(i),"function"==typeof i.postConstruct&&i.postConstruct(),i}getValueFromClass(t,...e){for(const i in this.mappings)if(this.mappings.hasOwnProperty(i)){const n=this.mappings[i];if(n.cl===t)return n.singleton?(n.value||(n.value=this.createInstance(t,...e)),n.value):this.createInstance(t,...e)}if(this.parent)return this.parent.getValueFromClass(t,...e);if(this.throwOnMissing)throw new Error(h(void 0,t.name))}dispose(){this.mappings={}}}o.getExplicitInjectDependencies=function(t){if(void 0!==t.inject&&"[object Array]"===Object.prototype.toString.call(t.inject)&&t.inject.length>0){return t.inject}return[]},o.getDependencies=function(t){const c=[];function a(t,e,i){c.push(i)}const p=o.getExplicitInjectDependencies(t),h=t.toString().replace(r,"");let l;if(0===h.indexOf("class"))l=h.replace(/function constructor/g,"").match(i);else{if(0!==h.indexOf("function"))throw new Error(o.errors.DEPENDENCIES_INVALID_TARGET);l=h.match(e)}if(l){const t=l[1].split(n);for(let e=0,i=t.length;e<i;e++){const i=t[e].split("=")[0].replace(/\s/g,"");if(0===i.indexOf("..."))continue;(p&&p[e]?p[e]:i).replace(s,a)}}return c},Function.prototype.bind||(Function.prototype.bind=function(t,...e){const i=this;if("function"!=typeof i)throw new Error("Error, you must bind a function.");const n=e,s=function(...e){if(this instanceof s){const t=function(){};t.prototype=i.prototype;const s=new t,r=i.apply(s,n.concat(e));return Object(r)===r?r:s}return i.apply(t,n.concat(e))};return s});class u extends l{constructor(){super()}}class d{constructor(){this.listeners=[],this.halted=!1}add(t,e,i=0){return this.addListener(t,e,i,!1)}addOnce(t,e,i=0){return this.addListener(t,e,i,!0)}addListener(t,e,i,n){const s={handler:t,context:e,priority:i,once:n,active:!0,params:[]},r=this.listeners.findIndex(t=>t.priority<i);-1===r?this.listeners.push(s):this.listeners.splice(r,0,s);return{detach:()=>this.removeEntry(s),get active(){return s.active},set active(t){s.active=t},once:s.once,priority:s.priority,execute:t=>{if(s.active){const e=s.params.length>0?[...s.params,t]:[t];s.handler.apply(s.context,e)}},get params(){return s.params},set params(t){s.params=t}}}remove(t,e){const i=this.listeners.findIndex(i=>i.handler===t&&(void 0===e||i.context===e));-1!==i&&this.listeners.splice(i,1)}removeEntry(t){const e=this.listeners.indexOf(t);-1!==e&&this.listeners.splice(e,1)}removeAll(){this.listeners=[]}dispatch(t){this.halted=!1;const e=[...this.listeners],i=[];for(const n of e){if(this.halted)break;n.active&&(n.params.length>0?n.handler.apply(n.context,[...n.params,t]):n.handler.call(n.context,t),n.once&&i.push(n))}for(const t of i)this.removeEntry(t)}halt(){this.halted=!0}has(t,e){return this.listeners.some(i=>i.handler===t&&(void 0===e||i.context===e))}getNumListeners(){return this.listeners.length}dispose(){this.removeAll()}}class f{constructor(){this.signals={}}addListener(t,e,i,n){return this.signals[t]||(this.signals[t]=new d),this.signals[t].add(e,i,n)}addListenerOnce(t,e,i,n){return this.signals[t]||(this.signals[t]=new d),this.signals[t].addOnce(e,i,n)}removeListener(t,e,i){const n=this.signals[t];n&&n.remove(e,i)}getSignal(t){return this.signals[t]}haltSignal(t){const e=this.signals[t];e&&e.halt()}dispatch(t,e,i=!0){const n=this.signals[t];n&&(void 0!==e?(!i||"object"!=typeof e||null===e||Array.isArray(e)||"signalType"in e||(e.signalType=t),n.dispatch(e)):n.dispatch(void 0))}hasListeners(t){const e=this.signals[t];return!!e&&e.getNumListeners()>0}dispose(){for(const t in this.signals)Object.prototype.hasOwnProperty.call(this.signals,t)&&(this.signals[t].removeAll(),delete this.signals[t]);this.signals={}}}function m(t,e,i,n,s,...r){const o=t.createChild();o.mapValue("injector",o),o.mapValue("id",e),o.mapValue("signal",n),o.mapValue("binding",s);const c=o.createInstance(i);"function"==typeof c.execute&&c.execute.apply(c,r),o.dispose()}function g(t){return{setInjector:function(e){return t&&e&&(t.params[0]=e),g(t)}}}class _{constructor(t,e){this.list={},this.emitter=t,this.injector=e}add(t,e){if(this.list[t])throw new Error('[Commands] Error: a command with the id: "'+t+'" has already been registered');this.list[t]=e;const i=function(t,e,i){const n=t.emitter.addListener(e,m,t);return n.params=[t.injector,e,i,t.emitter.getSignal(e),n],n}(this,t,e);return g(i)}get(t){return this.list[t]}remove(t){this.list[t]&&(this.list[t]=void 0,delete this.list[t],function(t,e){const i=t.emitter.getSignal(e);i&&i.removeAll()}(this,t))}dispose(){for(const t in this.list)this.remove(t);this.list={},this.emitter=null,this.injector=void 0}}_.inject=["emitter","injector"];class E{constructor(){this.emitter=void 0,this.injector=void 0}create(t,e,i=!0){if(!this.injector)throw new Error("injector not present or has been disposed");if((n=e)&&"function"==typeof n.get&&"number"==typeof n.length){if(!e.length)return[];e=e.get()}var n;let s=[];const r=[];Array.isArray(e)&&e.length>0?s=i?[e]:[...e]:e instanceof HTMLElement?s=[e]:e instanceof NodeList&&(i?s=[e]:e.forEach(t=>{s.push(t)}));for(let e=0,i=s.length;e<i;e++){const i=this.injector.createChild();i.mapValue("injector",i),i.mapValue("target",s[e]);const n=i.createInstance(t);if(1===s.length)return n;r.push(n)}return r}dispose(){delete this.emitter,delete this.injector}}E.inject=["emitter","injector"];const I={};I.is={object:t=>"object"==typeof t&&null!==t,array:Array.isArray||(t=>"[object Array]"===Object.prototype.toString.call(t)),func:t=>"function"==typeof t},I.applyProperties=(t,e,i,n)=>{if("[object Array]"===Object.prototype.toString.apply(n))for(let s=0,r=n.length;s<r;s++)void 0!==t[n[s]]&&null!==t[n[s]]||(i&&"function"==typeof e[n[s]]?t[n[s]]=e[n[s]].bind(e):t[n[s]]=e[n[s]]);else for(const n in e)void 0!==t[n]&&null!==t[n]||(i&&"function"==typeof e[n]?t[n]=e[n].bind(e):t[n]=e[n])},I.augment=(t,e,i)=>{if(e.prototype&&t.prototype)if("[object Array]"===Object.prototype.toString.apply(i))for(let n=0,s=i.length;n<s;n++)t.prototype[i[n]]||(t.prototype[i[n]]=e.prototype[i[n]]);else for(const i in e.prototype)t.prototype[i]||(t.prototype[i]=e.prototype[i])},I.inherit=(t,e)=>{let i;i=e&&e.hasOwnProperty("constructor")?e.constructor:function(){return t.apply(this,arguments)};const n=function(){};return n.prototype=t.prototype,i.prototype=new n,e&&I.applyProperties(i.prototype,e),i.prototype.constructor=i,i.parent=t.prototype,i.extend=function(t){return I.inherit(i,t)},i},I.extend=t=>I.inherit(function(){},t);class N{constructor(t){this.injector=t,this.list={}}create(t,e,i,n){let s,r;const c=!1!==i,a=!0===n;if(I.is.func(t))r=t;else if(I.is.object(t)&&I.is.func(t.module))r=t.module;else{if(!I.is.object(t)||!I.is.func(t.Module))throw new Error("[Modules] Error: Could not create module. The module must be a function or an object containing a module property referencing a function.");r=t.Module}if(!(t=>{let e=!0;return(null==t||"string"!=typeof t.id)&&(e=!1),e})(r))throw new Error('[Modules] Error: Could not create module. The module function must contain a static "id" property, ex: function Module(){}; Module.id = "module-name"; ');if(r)if(this.has(r.id))s=this.get(r.id);else{let t=this.injector;a&&(t=this.injector.createChild(),t.mapValue("injector",t)),s=((t,e,i)=>{const n=o.getDependencies(e),s=e.hasOwnProperty("inject");let r=[e];for(let e=0,i=n.length;e<i;e++)t.hasMapping(n[e])||t.hasInheritedMapping(n[e])?r.push(t.getValue(n[e])):r.push(void 0);if(!s)for(let t=r.length-1;t>=0&&void 0===r[t];t--)r.splice(t,1);i&&(r=r.concat(i));const[c,...a]=r;return t.createInstance(c,...a)})(t,r,e),p=this.list,h=r.id,l=s,!p[h]&&c&&(p[h]=l),"function"==typeof s.init&&s.init()}var p,h,l;return s}has(t){return void 0!==this.list[t]}get(t){return this.list[t]}remove(t){this.list[t]&&("function"==typeof this.list[t].dispose&&this.list[t].dispose(),this.list[t]=void 0,delete this.list[t])}dispose(){for(const t in this.list)this.remove(t);this.list={}}}N.inject=["injector"];t.Application=class{get emitter(){return this._emitter||new f}get injector(){return this._injector||new u}set commands(t){this._commands=t}get commands(){if(!this._commands)throw new Error("Commands not initialized. Call setup() first.");return this._commands}get mediators(){return this._mediators||new E}get modules(){if(!this._modules)throw new Error("Modules not initialized. Call setup() first.");return this._modules}constructor(){this.setup(),this.init(),this.initDone()}setupEmitter(){this._injector&&(this._injector.mapClass("emitter",f,!0),this._emitter=this._injector.getValue("emitter"))}setup(){this._injector=new u,this._injector.throwOnMissing=!1,this._injector.mapValue("injector",this._injector),this._injector.mapValue("instance",this),this.setupEmitter(),this._injector.mapClass("commands",_,!0),this._commands=this._injector.getValue("commands"),this._injector.mapClass("mediators",E,!0),this._mediators=this._injector.getValue("mediators"),this._injector.mapClass("modules",N,!0),this._modules=this._injector.getValue("modules")}init(){}initDone(){}dispose(){this._injector&&this._injector.dispose(),this.emitter&&this.emitter.dispose(),this._commands&&this._commands.dispose(),this._mediators&&this._mediators.dispose(),this._modules&&this._modules.dispose(),this._injector=void 0,this._emitter=void 0,this._commands=void 0,this._mediators=void 0,this._modules=void 0}},t.Commands=_,t.Emitter=f,t.Mediators=E,t.Modules=N,t.Signal=d,t.infuse=o,t.utils=I,Object.defineProperty(t,"__esModule",{value:!0})});
